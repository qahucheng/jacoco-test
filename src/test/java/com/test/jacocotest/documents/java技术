java技术问题


分布式锁

线程安全问题
 	互斥同步，加锁、同步代码块
 	使用一些线程安全类，比如threadlocal


锁
互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系


java编程

面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象
封装：封装是指将对象的属性私有化，提供一些可以访问属性的方法，我们通过访问这些方法得到对象的属性。
保护或防止代码（数据）在无意中被破坏。保护类中的成员，不让类以外的程序直接访问或修改，只能通过提供的公共接口访问（数据封装）
继承：继承主要实现重用代码，节省开发时间，子类可以继承父类的属性和方法，且能够对基类的功能进行扩充、修改或重定义。
多态：同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作
通常来说我们定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定
多态的的实现方式有俩种： 继承（多个子类对同一方法的重写）和实现接口（实现接口并覆盖接口中同一方法）

== 和 equeal
== 比较的是引用
equal 比较的是值


final
final 修饰的类叫最终类，该类不能被继承。
final 修饰的方法不能被重写。
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。


String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。
byte short int long float double boolean char


StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。
因为 Stringbuffer 使用了 在append时 使用了 synchronized   实际上两者底层都是实现了Stringbuilder

transient
在持久化对象时，对于一些特殊的数据成员（如用户的密码，银行卡号等），我们不想用序列化机制来保存它。为了在一个特定对象的一个成员变量上关闭序列化，可以在这个成员变量前加上关键字transient。

8. String str="i"与 String str=new String("i")一样吗？
不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。




如何将字符串反转？
使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。


普通类和抽象类的区别
普通类不能包含抽象方法，抽象类可以包含抽象方法。
抽象类不能直接实例化，普通类可以直接实例化。


接口和抽象类的区别
相同点：
（1）都不能被实例化
（2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。
不同点：
（1）接口只有定义，不能有方法的实现，但java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
（3）接口强调特定功能的实现，而抽象类强调所属关系。



常用的工具类
Arrays.tostring
Arrays.sort
Arrays.asList
Collections.addAll


内部类
静态内部类。main方法
匿名内部类 匿名内部类没有class字段，直接时new出来的一个对象


异常体系
RuntimeException（运行时异常）：指在Java虚拟机正常运行期间抛出的异常，RuntimeException可以被捕获并处理，如果出现此情况，我们需要抛出异常或者捕获并处理异常。常见的有NullPointerException、ClassCastException、ArrayIndexOutOfBoundsException等
CheckedException（检查异常）：指在编译阶段Java编译器检查CheckedException异常，并强制程序捕获和处理此类异常，要求程序在可能出现异常的地方通过try catch语句块捕获异常并处理异常。常见的有由于I/O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常通常由于打开错误的文件、SQL语法错误、类不存等引起。


：深拷贝和浅拷贝都是对象拷贝

浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。

深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。


ArrayList底层使用的是 Object数组；LinkedList底层使用的是 双向链表 数据结构。
ArrayList:增删慢、查询快，线程不安全，对元素必须连续存储。
LinkedList:增删快，查询慢，线程不安全。


HashMap是基于数组和链表实现的，而且采用头插法


当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

实现线程安全的方案
分别是互斥同步、非阻塞同步和无同步方案。
互斥同步：同步是指多个线程并发访问共享数据时，保证共享数据在同一各时刻只被一条，互斥是实现同步的一种手段

非阻塞同步类似是一种乐观并发的策略，比如CAS 乐观锁 和悲观锁
syschronized 悲观锁
使用verison版本号 实现乐观锁


无同步方案，比如使用ThreadLocal。


线程池的方案。线程的状态。新建 new对象。就绪start 方法。运行开始执行 阻塞wait 、等待sleep、死亡
继承 thread 父类 重写run方法
实现 runnable 接口 重写run方法


线程池
newCacheThreadpool
newfixthreadpool
newschedulethreadpool
newsinglethreadpool



（1）当线程数小于核心线程数的时候，使用核心线程数。

（2）如果核心线程数小于线程数，就将多余的线程放入任务队列（阻塞队列）中

（3）当任务队列（阻塞队列）满的时候，就启动最大线程数.

（4）当最大线程数也达到后，就将启动拒绝策略。










