数据库

ACID，是指在可靠数据库管理系统中，事务具有的四个特性：原子性、一致性、隔离性、持久性.
原子性：指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。
隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
一致性：一致性是指在事务开始之前和事务结束以后，事务不能破坏关系数据的完整性以及业务逻辑上的一致性。比如转账操作，给b转100块，那么转账前后 a+b的总额肯定是不变的
持久性：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。


事务的隔离级别：读未提交、读已提交、可重复读（mysql默认）、串行化
可能导致的问题：脏读 不可重复读、幻读
https://blog.csdn.net/qq_39390545/article/details/107343711

mysql基本储备 redolog undolog binlog
https://blog.csdn.net/qq_39390545/article/details/115214802


重写日志 redolog。 撤销日志 undolog。redolog 物理日志。binlog 是逻辑日志

面试可能会遇到的问题：

redo log的概念是什么? 为什么会存在.
频繁的写入数据库IO的压力会和大，因此增加redo log先写入redolog，数据更新在缓存，后面批量将redo log中的操作落库
因此数据库即便突然宕机也能通过redolog快速恢复

什么是WAL(write-ahead logging)机制, 好处是什么.
先写redo log  再写磁盘

redo log 为什么可以保证crash safe机制.


binlog的概念是什么, 起到什么作用, 可以做crash safe吗?
binlog不是用来做crash safe的，binlog时归档日志，binlog记录了每条sql的执行操作，并且时大小不限的，因此可以用作临时库恢复
binlog和redolog的不同点有哪些?

binlog大小不限。redolog有大小限制
redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的
redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=1 这一行的 c 字段加 1 ”。


物理一致性和逻辑一致性各应该怎么理解?
执行器和innoDB在执行update语句时候的流程是什么样的?
先去根据制定条件查，如果内存能查到直接返回，如果查不到就去查存储
查到之后做更新，先写到redolog prepare。然后更新内存，然后在写到binlog binlog落磁盘，然后relog落磁盘
如果数据库误操作, 如何执行数据恢复?

什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?
先写redolog 后写binlog 如果写binlog失败了
那么后面恢复数据库的时候 redolog这个事务已经提交了，通过binlog恢复 就会没有这条变更
先写binlog 后写redolog 如果写redolog失败了
如果后面数据库恢复的时候，使用binlog 会发现这个数据不对，redo失败了那么事务就失效了

如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?


第一范式(确保每列保持原子性)、第二范式(确保表中的每列都和主键相关)、第三范式(确保每列都和主键列直接相关,而不是间接相关)


第一范式 （1NF）【字段不可再分】

“地址” 仍可以拆分成 “省”、“市”、“区县”、“详细地址”。

第二范式 （2NF）【每一行数据只做一件事】

商家表中，若维护门店ID、门店名称、门店地址，就不符合第二范式，应该专门拆分出门店表。

第三范式 （3NF） 【每个属性都和主键有直接关系】

学生表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）就不满足第三范式，应该拆分成：（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）。



https://cloud.tencent.com/developer/article/1543335

索引：

1、索引为什么要用 b+树这种数据结构？
二叉树会需要多次io。极限情况下会变成链表

 B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。

索引是帮助数据库高效获取数据的数据结构。
相反来说

2）从应用层次上来划分
普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。
唯一索引：索引列的值必须唯一，但允许有空值。
复合索引：一个索引包含多个列。

B+树索引按照存储方式的不同分为聚集索引和非聚集索引。

聚集索引：以主键作为B+树索引的键值而构建的B+树索引,在叶子节点存储的是表中的数据。
非聚集索引：以主键以外的列值作为键值构建的B+树索引，在叶子节点存储的是主键和索引列,我们称之为非聚集索引

想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。

3、索引什么时候会失效，最左匹配原则是什么？


一条sql 的执行步骤？
给到server端进行处理-》查询缓存，有就返回 没有就继续查 -〉解析 SQL（看看关键词对不对）预处理（查看相应的数据列对不对）优化sql，根据索引进行优化，返回数据给客户端


最左匹配原则
最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。
例如某表现有索引(a,b,c)，现在你有如下语句：

select * from t where a=1 and b=1;     #这样可以利用到定义的索引（a,b,c）,用上a,b
select * from t where a=1 and c=1;     #这样可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到
select * from t where b=1 and c=1;     #这样不可以利用到定义的索引（a,b,c）

因为范围查询(>、<、between、like)就会停止匹配
select * from t where a=1 and b>1 and c =1; #这样a,b可以用到（a,b,c），c索引用不到

但是如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引，因为优化器会自动改写为最优查询语句
select * from t where a=1 and b >1 and c=1;  #如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引
#优化器改写为
select * from t where a=1 and c=1 and b >1;

为什么要使用联合索引
1、减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！

2、效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！


