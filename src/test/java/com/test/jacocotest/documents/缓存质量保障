缓存


缓存雪崩
 一瞬间大量缓存失效，可以对key设置不同的过期时间
 异步定时的更新缓存
 双重缓存

 缓存击穿
 热点数据突然失效，不设置过期时间，由redis进行淘汰

 缓存穿透
 缓存的数据不在数据库 也不在缓存中，那么key已使用一个空对象或者布隆过滤器

redis  集合类型  String List  set  zSet hash

string 常规存储
hash(map) key value 健值
  list 常见用于个人发一条微博这种
   set 统计站点统计的ip
    zset。统计排名

如果说 对于有时间先后顺序的一些数据存储，可以用list 增删会比较高效

如果说对于想要存储一些唯一性的数据，如ip 或者 url 使用set存储可以比较直接做一些过滤

如果说希望有一些不重合但是希望有排序，比如排行榜之类的  用 zset


常见的redis问题：
 1、db和cache的一致性，没有完全一致性，只有最终一致性


 无论是先写mysql 再写redis 或者 先写redis再写mysql 都会有因为请求先后顺序并发情况下的不一致问题

 若是先删除redis 再写mysql，若期间发生了多次读，因为读请求比写请求更快，那么有大概率会使的redis的数据被读请求更新为旧数据

 先删除redis 再删mysql 再删redis 会因为上面这种情况，实际要求最后一次删除是在redis写之后，那么保障在写redis之后就可以用kafka队列延迟处理即可 对上面的扩展

 先写mysql 再删redis的话，基本可以容忍，

 2、缓存的依赖性，是否可以降级处理，强依赖缓存肯定是有问题的，可以设置多层缓存


 3、写入缓存的数据正确性，可以通过功能测试进行验证


Redis

持久化机制：RDB和AOF


AOF：一个是持续的用日志记录写操作，crash后利用日志恢复；RDB：一个是平时写操作的时候不触发写，只有手动提交save命令，或者是关闭命令时，才触发备份操作。

RDB优点
RDB 是紧凑的二进制文件，比较适合备份，全量复制等场景
RDB 恢复数据远快于 AOF
RDB缺点
RDB 无法实现实时或者秒级持久化；
新老版本无法兼容 RDB 格式。

AOF优点
可以更好地保护数据不丢失；
适合做灾难性的误删除紧急恢复。
AOF缺点：
对于同一份文件，AOF 文件要比 RDB 快照大；
AOF 开启后，会对写的 QPS 有所影响，相对于 RDB 来说 写 QPS 要下降；
数据库恢复比较慢， 不合适做冷备。


Redis的缓存淘汰策略

noevction：一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。Redis 用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间，我们不把它用在 Redis 缓存中。
volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。
volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。
volatile-lru 会使用 LRU 算法(下文具体介绍)筛选设置了过期时间的键值对。
volatile-lfu 会使用 LFU 算法(下文具体介绍)选择设置了过期时间的键值对。
allkeys-random 策略，从所有键值对中随机选择并删除数据。
allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。
allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。



惰性过期策略

只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

定期过期策略

每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

Redis中同时使用了惰性过期和定期过期两种过期策略。

所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。

**假设 redis 里放了 10w 个 key，都设置了过期时间，**你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。**注意，**这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。

**但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？**所以就是惰性删除了。这就是说，在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。

**获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。**但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？答案是：走内存淘汰机